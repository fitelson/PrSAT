% PrSAT 3.0b: The Probability Table Generator (Beta)
% Koissi & Branden 
% August 21, 2025
 
% PrSAT 3.0 is an open source, ASCII/web based probability table generator.  
% It runs on any modern browser, and requires no additional software.
% It takes (arbitrary) sets of statements in probability calculus as input (in ASCII format).
% If the set is satisfiable, it will return a probability distribution (in the form of a probability table).
% If not, it will return "unsatisfiable."
% 
% Here is a brief video demo of the software.

% Some simple theorems

% probability of the conditional vs conditional probability
Pr(X > Y) < Pr(Y | X)

% Three Forms of Bayes's Theorem
Pr(H | E) ≠ Pr(E | H)* Pr(H) / (Pr(E | H)* Pr(H) + Pr(E | ~H) * Pr(~H))

Pr(H | E)/Pr(~H | E) ≠ (Pr(E | H)/Pr(E | ~H))*(Pr(H)/Pr(~H))

Pr(H | E) ≠ 1 / (1 + (Pr(E | ~H)/Pr(E | H))*(Pr(~H)/Pr(H)))

% Some Simple non-Theorems 

% Simpson's Paradox 
Pr(X | Y & Z) > Pr(X | Z)
Pr(X | Y & ~Z) > Pr(X | ~Z)
Pr(X | Y) < Pr(X)

% simplify the models with these numerical constraints
Pr(X)=1/2
Pr(Y)=1/2

% an unsatisfiable triple, resembling Simpson's Paradox
Pr(X | Y & Z) > Pr(X)
Pr(X | Y & ~Z) > Pr(X)
Pr(X | Y) < Pr(X)

% Cute Biconditional theorem
% Theorem: (1) & (2) IFF (3)
% (1) Pr(A | A <-> B) = Pr(A | ~(A <-> B))
% (2) Pr(B | A <-> B) = Pr(B | ~(A <-> B))
% (3) Pr(A) = Pr(B) = 1/2

% IF direction (I)
Pr(A) = Pr(B)
Pr(A) = 1/2
Pr(A | A <-> B) ≠ Pr(A | ~(A <-> B))

% IF direction (II)
Pr(A) = Pr(B)
Pr(A) = 1/2
Pr(B | A <-> B) ≠ Pr(B | ~(A <-> B))

% ONLY IF direction (I)
Pr(A | A <-> B) = Pr(A | ~(A <-> B))
Pr(B | A <-> B) = Pr(B | ~(A <-> B))
Pr(A) ≠ Pr(B)

% ONLY IF direction (II)
Pr(A | A <-> B) = Pr(A | ~(A <-> B))
Pr(B | A <-> B) = Pr(B | ~(A <-> B))
Pr(A) ≠ 1/2

% Irrational-only example
Pr(C | B) = Pr(C \/ B)
Pr(B & C) = Pr(~B & C)
Pr(C) = Pr(~C)

% failure of AND for relevance
Pr(B | A) > Pr(B)
Pr(C | A) > Pr(C)
Pr(B & C | A) ≤ Pr(B & C)

% failure of OR for relevance
Pr(B | A) > Pr(B)
Pr(C | A) > Pr(C)
Pr(B \/ C | A) ≤ Pr(B \/ C)

% AND/OR property of relevance
Pr(B | A) > Pr(B)
Pr(C | A) > Pr(C)
Pr(B \/ C | A) ≤ Pr(B \/ C)
Pr(B & C | A) ≤ Pr(B & C)

% Reichenbach's Conjunctive Fork Theorem
Pr(E1 | E2 & C) = Pr(E1 | C)
Pr(E1 | E2 & ~C) = Pr(E1 | ~C)
Pr(E1 | C) > Pr(E1)
Pr(E2 | C) > Pr(E2)
Pr(E1 | E2) ≤ Pr(E1)

% intransitivity of relevance
Pr(B | A) > Pr(B)
Pr(C | B) > Pr(C)
Pr(C | A) ≤ Pr(C)

% Screening off is sufficient for transitivity of relevance (verifies in ~40s)
Pr(B | A) > Pr(B)
Pr(C | B) > Pr(C)
Pr(C | B & A) = Pr(C | A)
Pr(C | B & ~A) = Pr(C | ~A)
Pr(C | A) ≤ Pr(C)

% Three props which are pairwise independent but not independent
% This produces an irregular model by default
% If we ask it for a regular model, it gives irrational numbers
Pr(X & Y) = Pr(X) * Pr(Y)
Pr(X & Z) = Pr(X) * Pr(Z)
Pr(Y & Z) = Pr(Y) * Pr(Z)
Pr(X & Y & Z) ≠ Pr(X) * Pr(Y) * Pr(Z)

% If we add this numerical constraint, then it gives a nice urn model
Pr(X) = 1/2

% Four props that are 2-wise and 3-wise independent, but not 4-wise independent
% It can't solve this one without additional numerical constraints (in up to 3 mins)
Pr(X & Y) = Pr(X) * Pr(Y)
Pr(X & Z) = Pr(X) * Pr(Z)
Pr(Y & Z) = Pr(Y) * Pr(Z)
Pr(X & U) = Pr(X) * Pr(U)
Pr(Y & U) = Pr(Y) * Pr(U)
Pr(Z & U) = Pr(Z) * Pr(U)
Pr(X & Y & Z) = Pr(X) * Pr(Y) * Pr(Z)
Pr(X & Y & U) = Pr(X) * Pr(Y) * Pr(U)
Pr(X & Z & U) = Pr(X) * Pr(Z) * Pr(U)
Pr(Y & Z & U) = Pr(Y) * Pr(Z) * Pr(U)
Pr(X & Y & Z & U) ≠ Pr(X) * Pr(Y) * Pr(Z) * Pr(U)

% with just this constraint, it gives irrational numbers
Pr(X)=1/2

% with one more numerical constraint, it gives a nice urn model
Pr(Y)=1/2

% Z- measure impossibility (trivial)
Pr(H | E1) > Pr(H)
Pr(H | E2) < Pr(H)
(Pr(H | E1 & E2) - Pr(H | E2)) / Pr(~H | E2) = (Pr(H | E1) - Pr(H)) / Pr(~H)
(Pr(H | E2 & E1) - Pr(H | E1)) / Pr(H | E1) = (Pr(H | E2) - Pr(H)) / Pr(H)

% S-measure impossibility (there are no REGULAR models for this, but there are SOME models)
% Note: for any value other than 1/2 there are Regular models...
(Pr(H | E1 & E2) - Pr(H | ~E1 & E2)) = (Pr(H | E1) - Pr(H | ~E1))
(Pr(H | E2 & E1) - Pr(H | ~E2 & E1)) = (Pr(H | E2) - Pr(H | ~E2))
Pr(H | E1) - Pr(H | ~E1) = 1/2
Pr(H | E2) - Pr(H | ~E2) = -1/2
Pr(H | E1 & E2) - Pr(H | ~(E1 & E2)) ≠ 0

% Wason result verification -- easily solved
Pr(B | H & R) = 1
Pr(~B)/Pr(R) ≥ Pr(~B | H)/Pr(R | H)
Pr(~B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0 
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(B | R) * (Pr(H | R & B) - Pr(H | R)) + Pr(~B | R) * Pr(H | R) ≤ Pr(R | ~B) * Pr(H | ~B) + Pr(~R | ~B) * (Pr(H | ~R & ~B) - Pr(H | ~B))

% Wason/Rvens problem -- non-triviality model for KO measure.  Finds a simpler model than Mathematica's!
Pr(B | H & R) = 1
Pr(~B)/Pr(R) >= Pr(~B | H)/Pr(R | H) 
Pr(~B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(B | R) * ((Pr(B | H & R) - Pr(B | ~H & R))/( Pr(B | H & R) + Pr(B | ~H & R))) * (( Pr(B | H & R) - Pr(B | ~H & R))/( Pr(B | H & R) + Pr(B | ~H & R))) + Pr(~B | R) * (( Pr(~B | H & R) - Pr(~B | ~H & R))/( Pr(~B | H & R) + Pr(~B | ~H & R))) * (( Pr(~B | H & R) - Pr(~B | ~H & R))/( Pr(~B | H & R) + Pr(~B | ~H & R))) >= Pr(R | ~B) * (( Pr(R | H & ~B) - Pr(R | ~H & ~B))/( Pr(R | H & ~B) + Pr(R | ~H & ~B))) * (( Pr(R | H & ~B) - Pr(R | ~H & ~B))/( Pr(R | H & ~B) + Pr(R | ~H & ~B))) + Pr(~R | ~B) * (( Pr(~R | H & ~B) - Pr(~R | ~H & ~B))/( Pr(~R | H & ~B) + Pr(~R | ~H & ~B))) * (( Pr(~R | H & ~B) - Pr(~R | ~H & ~B))/( Pr(~R | H & ~B) + Pr(~R | ~H & ~B)))

% Wason/Rvens problem -- trying to verify the KO version of the theorem -- hard
% It verifies this result -- and in under 30s!  I was not able to get any solver to do this!  Huge.
Pr(B | H & R) = 1
Pr(~B)/Pr(R) >= Pr(~B | H)/Pr(R | H) 
Pr(~B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(B | R) * ((Pr(B | H & R) - Pr(B | ~H & R))/( Pr(B | H & R) + Pr(B | ~H & R))) * (( Pr(B | H & R) - Pr(B | ~H & R))/( Pr(B | H & R) + Pr(B | ~H & R))) + Pr(~B | R) * (( Pr(~B | H & R) - Pr(~B | ~H & R))/( Pr(~B | H & R) + Pr(~B | ~H & R))) * (( Pr(~B | H & R) - Pr(~B | ~H & R))/( Pr(~B | H & R) + Pr(~B | ~H & R))) < Pr(R | ~B) * (( Pr(R | H & ~B) - Pr(R | ~H & ~B))/( Pr(R | H & ~B) + Pr(R | ~H & ~B))) * (( Pr(R | H & ~B) - Pr(R | ~H & ~B))/( Pr(R | H & ~B) + Pr(R | ~H & ~B))) + Pr(~R | ~B) * (( Pr(~R | H & ~B) - Pr(~R | ~H & ~B))/( Pr(~R | H & ~B) + Pr(~R | ~H & ~B))) * (( Pr(~R | H & ~B) - Pr(~R | ~H & ~B))/( Pr(~R | H & ~B) + Pr(~R | ~H & ~B)))

% Another negative Wason result —- that u(B) > u (~B) does NOT follow from the strong Byesian assumptions.  
% Finds a nice simple urn model.
Pr(B | H & R) = 1 
Pr(H | R) = Pr(H | ~R)
Pr(H | B) = Pr(H | ~B)
Pr(~B) > Pr(B)
Pr(B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(R | B) * (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B)) + Pr(~R | B) * (Pr(H | ~R & B) - Pr(H | B)) * (Pr(H | ~R & B) - Pr(H | B)) < Pr(R | ~B) * (Pr(H | R & ~B) - Pr(H | ~B)) * (Pr(H | R & ~B) - Pr(H | ~B)) + Pr(~R | ~B) * (Pr(H | ~R & ~B) - Pr(H | ~B)) * (Pr(H | ~R & ~B) - Pr(H | ~B))

% And here is the positive result -- that absence of confirmation bias fills this gap 
% it can't solve this one -- even in 5 minutes 
% BUT -- if we change "≠ 0" in the SMT to "> 0" for the defined-ness conditions, then it solves instantly (see SMT code below)
Pr(B | H & R) = 1 
Pr(H | R) = Pr(H | ~R)
Pr(H | B) = Pr(H | ~B)
Pr(~B) > Pr(B)
Pr(B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(R | B) <= Pr(R | ~B)
Pr(R | B) * (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B)) + Pr(~R | B) * (Pr(H | ~R & B) - Pr(H | B)) * (Pr(H | ~R & B) - Pr(H | B)) <= Pr(R | ~B) * (Pr(H | R & ~B) - Pr(H | ~B)) * (Pr(H | R & ~B) - Pr(H | ~B)) + Pr(~R | ~B) * (Pr(H | ~R & ~B) - Pr(H | ~B)) * (Pr(H | ~R & ~B) - Pr(H | ~B))

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(assert (>= s_0 0))
(assert (>= s_1 0))
(assert (>= s_2 0))
(assert (>= s_3 0))
(assert (>= s_4 0))
(assert (>= s_5 0))
(assert (>= s_6 0))
(assert (<= (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6) 1))
(assert (> (+ s_0 s_4) 0))
(assert (> (+ s_0 s_2 s_4 s_6) 0))
(assert (> (- 1 (+ s_0 s_2 s_4 s_6)) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (+ s_0 s_2) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (+ s_0 s_2) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (+ s_1 s_3) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (+ s_1 s_3) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (+ s_4 s_6) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (+ s_4 s_6) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6)) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6)) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (= (/ s_0 (+ s_0 s_4)) 1))
(assert (= (/ (+ s_0 s_4) (+ s_0 s_2 s_4 s_6)) (/ (+ s_1 s_5) (- 1 (+ s_0 s_2 s_4 s_6)))))
(assert (= (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) (+ s_0 s_1 s_2 s_3)))
(assert (> (+ s_0 s_1 s_2 s_3) (+ s_0 s_2 s_4 s_6)))
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_5 0))
(assert (> s_2 0))
(assert (> s_6 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6)) 0))
(assert (> s_3 0))
(assert (<= (/ (+ s_0 s_2) (+ s_0 s_1 s_2 s_3)) (/ (+ s_4 s_6) (- 1 (+ s_0 s_1 s_2 s_3)))))
(assert (<= (+ (* (/ (+ s_0 s_2) (+ s_0 s_1 s_2 s_3)) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3)))) (* (/ (+ s_1 s_3) (+ s_0 s_1 s_2 s_3)) (- (/ s_1 (+ s_1 s_3)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_1 (+ s_1 s_3)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))))) (+ (* (/ (+ s_4 s_6) (- 1 (+ s_0 s_1 s_2 s_3))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))) (* (/ (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6)) (- 1 (+ s_0 s_1 s_2 s_3))) (- (/ s_5 (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6))) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_5 (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6))) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))))))
(check-sat)


% Here is a non-triviality model for the full Bayesian assumptions + the full Nickerson ordering + no confirmation bias.  Easily finds a simple urn model.
Pr(B | H & R) = 1 
Pr(H | R) = Pr(H | ~R)
Pr(H | B) = Pr(H | ~B)
Pr(~B) > Pr(B)
Pr(B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(R | B) <= Pr(R | ~B)
Pr(R | B) * (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B)) + Pr(~R | B) * (Pr(H | ~R & B) - Pr(H | B)) * (Pr(H | ~R & B) - Pr(H | B)) > Pr(R | ~B) * (Pr(H | R & ~B) - Pr(H | ~B)) * (Pr(H | R & ~B) - Pr(H | ~B)) + Pr(~R | ~B) * (Pr(H | ~R & ~B) - Pr(H | ~B)) * (Pr(H | ~R & ~B) - Pr(H | ~B))
Pr(B | R) * (Pr(H | R & B) - Pr(H | R)) * (Pr(H | R & B) - Pr(H | R)) + Pr(~B | R) * (Pr(H | R & ~B) - Pr(H | R)) * (Pr(H | R & ~B) - Pr(H | R)) > Pr(R | B) * (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B)) + Pr(~R | B) * (Pr(H | ~R & B) - Pr(H | B)) * (Pr(H | ~R & B) - Pr(H | B))

% Here is the Wason (positive) confirmation-bias result --- solves it in ~45s)
% In this case, using "> 0" rather than "≠ 0" for the defined-ness conditions *prevents* solution (see SMT code below)
Pr(B | H & R) = 1 
Pr(~B)/Pr(R) >= Pr(~B | H)/Pr(R | H) 
Pr(~B) > Pr(B)
Pr(B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(R | B) * (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B)) + Pr(~R | B) * (Pr(H | ~R & B) - Pr(H | B)) * (Pr(H | ~R & B) - Pr(H | B))  > Pr(R | ~B) * (Pr(H | R & ~B) - Pr(H | ~B)) * (Pr(H | R & ~B) - Pr(H | ~B)) + Pr(~R | ~B) * (Pr(H | ~R & ~B) - Pr(H | ~B)) * (Pr(H | ~R & ~B) - Pr(H | ~B))
(Pr(H | R & ~B) - Pr(H | ~B)) * (Pr(H | R & ~B) - Pr(H | ~B)) > (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B))
Pr(R | B) <= Pr(R | ~B)

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(assert (>= s_0 0))
(assert (>= s_1 0))
(assert (>= s_2 0))
(assert (>= s_3 0))
(assert (>= s_4 0))
(assert (>= s_5 0))
(assert (>= s_6 0))
(assert (<= (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6) 1))
(assert (not (= (+ s_0 s_2 s_4 s_6) 0)))
(assert (not (= (/ (+ s_0 s_4) (+ s_0 s_1 s_4 s_5)) 0)))
(assert (> (+ s_0 s_4) 0))
(assert (> (+ s_0 s_1 s_4 s_5) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (+ s_0 s_2) 0))
(assert (> (+ s_1 s_3) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (+ s_4 s_6) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6)) 0))
(assert (= (/ s_0 (+ s_0 s_4)) 1))
(assert (>= (/ (- 1 (+ s_0 s_1 s_2 s_3)) (+ s_0 s_2 s_4 s_6)) (/ (+ s_4 s_5) (+ s_0 s_1 s_4 s_5) (/ (+ s_0 s_4) (+ s_0 s_1 s_4 s_5)))))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) (+ s_0 s_1 s_2 s_3)))
(assert (> (+ s_0 s_1 s_2 s_3) (+ s_0 s_2 s_4 s_6)))
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_5 0))
(assert (> s_2 0))
(assert (> s_6 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6)) 0))
(assert (> s_3 0))
(assert (> (+ (* (/ (+ s_0 s_2) (+ s_0 s_1 s_2 s_3)) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3)))) (* (/ (+ s_1 s_3) (+ s_0 s_1 s_2 s_3)) (- (/ s_1 (+ s_1 s_3)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_1 (+ s_1 s_3)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))))) (+ (* (/ (+ s_4 s_6) (- 1 (+ s_0 s_1 s_2 s_3))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))) (* (/ (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6)) (- 1 (+ s_0 s_1 s_2 s_3))) (- (/ s_5 (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6))) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_5 (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6))) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))))))
(assert (<= (/ (+ s_0 s_2) (+ s_0 s_1 s_2 s_3)) (/ (+ s_4 s_6) (- 1 (+ s_0 s_1 s_2 s_3)))))
(assert (> (* (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))) (* (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))))))
(check-sat)


% It does  find a non-triviality model for this one (in ~40s)
% It finds an even simpler model (in similar time) if we replace "≠ 0" with "> 0" in defined-ness conditions (see SMT code below)
Pr(B | H & R) = 1 
Pr(~B)/Pr(R) >= Pr(~B | H)/Pr(R | H) 
Pr(~B) > Pr(B)
Pr(B) > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(R | B) * (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B)) + Pr(~R | B) * (Pr(H | ~R & B) - Pr(H | B)) * (Pr(H | ~R & B) - Pr(H | B))  > Pr(R | ~B) * (Pr(H | R & ~B) - Pr(H | ~B)) * (Pr(H | R & ~B) - Pr(H | ~B)) + Pr(~R | ~B) * (Pr(H | ~R & ~B) - Pr(H | ~B)) * (Pr(H | ~R & ~B) - Pr(H | ~B))
Pr(R | B) > Pr(R | ~B)
(Pr(H | R & ~B) - Pr(H | ~B)) * (Pr(H | R & ~B) - Pr(H | ~B)) > (Pr(H | R & B) - Pr(H | B)) * (Pr(H | R & B) - Pr(H | B))

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(assert (>= s_0 0))
(assert (>= s_1 0))
(assert (>= s_2 0))
(assert (>= s_3 0))
(assert (>= s_4 0))
(assert (>= s_5 0))
(assert (>= s_6 0))
(assert (<= (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6) 1))
(assert (not (= (+ s_0 s_4) 0)))
(assert (not (= (+ s_0 s_2 s_4 s_6) 0)))
(assert (not (= (/ (+ s_0 s_4) (+ s_0 s_1 s_4 s_5)) 0)))
(assert (> (+ s_0 s_1 s_4 s_5) 0))
(assert (> (+ s_0 s_1 s_2 s_3) 0))
(assert (> (+ s_0 s_2) 0))
(assert (> (+ s_1 s_3) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) 0))
(assert (> (+ s_4 s_6) 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6)) 0))
(assert (= (/ s_0 (+ s_0 s_4)) 1))
(assert (>= (/ (- 1 (+ s_0 s_1 s_2 s_3)) (+ s_0 s_2 s_4 s_6)) (/ (+ s_4 s_5) (+ s_0 s_1 s_4 s_5) (/ (+ s_0 s_4) (+ s_0 s_1 s_4 s_5)))))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3)) (+ s_0 s_1 s_2 s_3)))
(assert (> (+ s_0 s_1 s_2 s_3) (+ s_0 s_2 s_4 s_6)))
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_5 0))
(assert (> s_2 0))
(assert (> s_6 0))
(assert (> (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6)) 0))
(assert (> s_3 0))
(assert (> (+ (* (/ (+ s_0 s_2) (+ s_0 s_1 s_2 s_3)) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3)))) (* (/ (+ s_1 s_3) (+ s_0 s_1 s_2 s_3)) (- (/ s_1 (+ s_1 s_3)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_1 (+ s_1 s_3)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))))) (+ (* (/ (+ s_4 s_6) (- 1 (+ s_0 s_1 s_2 s_3))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))) (* (/ (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6)) (- 1 (+ s_0 s_1 s_2 s_3))) (- (/ s_5 (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6))) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_5 (- 1 (+ s_0 s_1 s_2 s_3 s_4 s_6))) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))))))
(assert (> (/ (+ s_0 s_2) (+ s_0 s_1 s_2 s_3)) (/ (+ s_4 s_6) (- 1 (+ s_0 s_1 s_2 s_3)))))
(assert (> (* (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3)))) (- (/ s_4 (+ s_4 s_6)) (/ (+ s_4 s_5) (- 1 (+ s_0 s_1 s_2 s_3))))) (* (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))) (- (/ s_0 (+ s_0 s_2)) (/ (+ s_0 s_1) (+ s_0 s_1 s_2 s_3))))))
(check-sat)
(get-model)


% Sidebar on Nickerson's numerical model: Nickerson's numerical assumption that P[H] = 1/2, 
% which may seem innocuous, actually entails (given only our weak background assumptions 
% + the additional assumption that Pr(~Ba)>8/10) that Pr[Ra | Ba]  > Pr[Ra | ~Ba].  
% Here is a demonstration -- easily verified with Koissi's program
Pr(B | H & R) = 1 
Pr(~B)/Pr(R) >= Pr(~B | H)/Pr(R | H) 
Pr(~B) > 8/10
8/10 > Pr(R)
Pr(H & R & B) > 0
Pr(H & ~R & B) > 0
Pr(H & ~R & ~B) > 0
Pr(~H & R & B) > 0
Pr(~H & R & ~B) > 0
Pr(~H & ~R & ~B) > 0
Pr(~H & ~R & B) > 0
Pr(H) = 1/2
Pr(R | B) ≤ Pr(R | ~B)

% Salmon's sufficient condition for AND (verifies this)
Pr(B | A) > Pr(B)
Pr(C | A) > Pr(C)
Pr(C | A) - Pr(C) = Pr(C | A & B) - Pr(C | B)
Pr(B & C | A) <= Pr(B & C)

% Salmon's sufficient condition for OR (verifies this -- in under 1m)
Pr(B | A) > Pr(B)
Pr(C | A) > Pr(C)
Pr(C | A) - Pr(C) = Pr(C | A & B) - Pr(C | B)
Pr(B \/ C | A) <= Pr(B \/ C)

% Our weaker Salmonian sufficient condition for AND (assuming Regularity, case 1 -- easily verified)
% This is a nice example to illustrate when Regularity can make a difference
Pr(B | A) > Pr(B)
Pr(C | A) > Pr(C)
Pr(C | A & B) ≥ Pr(C | B)
Pr(B & C | A) <= Pr(B & C)

% Our weaker sufficient condition for OR (assuming Regularity, case 1 -- verifies this too, in under 1m)
Pr(B | A) > Pr(B)
Pr(C | A) > Pr(C)
Pr(C | A) - Pr(C) ≥ Pr(C | A & B) - Pr(C | B)
Pr(B \/ C | A) <= Pr(B \/ C)

% robustness of our Salmonian condition for OR —- for the m measure 
% (Koissi's program does this -- none of the others do)
% this one is also hard for the language models to prove rigorously  -- good test problem!
Pr(C | A) > Pr(C)
Pr(B | A) > Pr(B)
Pr(A | C) - Pr(A | ~C) ≥ Pr(A | C & B) - Pr(A | ~C & B)
Pr(B \/ C | A) ≤ Pr(B \/ C)

% robustness of our Salmonian condition for OR —- for the s measure 
% (Koissi's program does this -- none of the others do)
% this one is also hard for the language models to prove rigorously  -- good test problem!
Pr(C | A) > Pr(C)
Pr(B | A) > Pr(B)
Pr(C | A) - Pr(C | ~A) ≥ Pr(C | A & B) - Pr(C | ~A & B)
Pr(B \/ C | A) ≤ Pr(B \/ C)

% robustness of our Salmonian condition for OR —- for the l measure 
% (Koissi's program does not solve this either -- for regular models)
% it does find a model when regularity is relaxed though (as does my Mathematica implementation)
Pr(C | A) > Pr(C)
Pr(B | A) > Pr(B)
(Pr(A | C) - Pr(A | ~C))/(Pr(A | C) + Pr(A | ~C)) ≥ (Pr(A | C & B) - Pr(A | ~C & B))/(Pr(A | C & B) + Pr(A | ~C & B))
Pr(B \/ C | A) ≤ Pr(B \/ C)

% Our Triviality Result (trivial for the program)
Pr(C) = Pr(Q | P)
Pr(C | ~Q) = Pr(Q | P & ~Q)
Pr(C | ~P \/ Q) = Pr(Q | P & (~P \/ Q))
Pr(P & (Q <> C)) < 1

% Industrial Strength Example with 63 real variables
% Example #2: 63 real variables -- solved instantly by PrSAT 3.0b.  
% Takes 600+ seconds on PrSAT 2.5 random search!
Pr(A & B & H) = Pr(A) * Pr(B) * Pr(H | A & B)
Pr(A & B & ~H) = Pr(A) * Pr(B) * Pr(~H | A & B)
Pr(A & ~B & H) = Pr(A) * Pr(~B) * Pr(H | A & ~B)
Pr(A & ~B & ~H) = Pr(A) * Pr(~B) * Pr(~H | A & ~B)
Pr(~A & B & H) = Pr(~A) * Pr(B) * Pr(H | ~A & B)
Pr(~A & B & ~H) = Pr(~A) * Pr(B) * Pr(~H | ~A & B)
Pr(~A & ~B & H) = Pr(~A) * Pr(~B) * Pr(H | ~A & ~B)
Pr(~A & ~B & ~H) = Pr(~A) * Pr(~B) * Pr(~H | ~A & ~B)
Pr(A & B & H) = Pr(F & G & Y)
Pr(A & B & ~H) = Pr(F & G & ~Y)
Pr(A & ~B & H) = Pr(F & ~G & Y)
Pr(A & ~B & ~H) = Pr(F & ~G & ~Y)
Pr(~A & B & H) = Pr(~F & G & Y)
Pr(~A & B & ~H) = Pr(~F & G & ~Y)
Pr(~A & ~B & H) = Pr(~F & ~G & Y)
Pr(~A & ~B & ~H) = Pr(~F & ~G & ~Y)
Pr(F & G & Y) = Pr(F) * Pr(G | F) * Pr(Y | F & G)
Pr(F & G & ~Y) = Pr(F) * Pr(G | F) * Pr(~Y | F & G)
Pr(F & ~G & Y) = Pr(F) * Pr(~G | F) * Pr(Y | F & ~G)
Pr(F & ~G & ~Y) = Pr(F) * Pr(~G | F) * Pr(~Y | F & ~G)
Pr(~F & G & Y) = Pr(~F) * Pr(G | ~F) * Pr(Y | ~F & G)
Pr(~F & G & ~Y) = Pr(~F) * Pr(G | ~F) * Pr(~Y | ~F & G)
Pr(~F & ~G & Y) = Pr(~F) * Pr(~G | ~F) * Pr(Y | ~F & ~G)
Pr(~F & ~G & ~Y) = Pr(~F) * Pr(~G | ~F) * Pr(~Y | ~F & ~G)
Pr(H | A) > Pr(H)
Pr(H | B) > Pr(H)
Pr(A & B) = Pr(A) * Pr(B)
Pr(H | F) > Pr(H)
Pr(H | G) > Pr(H)
Pr(A) = Pr(F)
Pr(B) = Pr(G)
Pr(A) = 1/6
Pr(B) = 1/6
Pr(H) = 1/6
Pr(F) = 1/6
Pr(G) = 1/6
Pr(Y) = 1/6
Pr(A & H)/(Pr(A) * Pr(H)) = Pr(F & H)/(Pr(F) * Pr(H))

% Showing d,l are not ordinally equivalent (does not solve this -- in even 2 mins)
% But, it does if we replave "≠ 0" with "> 0" in the defined-ness conditions (see SMT code below)
Pr(H1 | E1) - Pr(H1) > Pr(H2 | E2) - Pr(H2)
Pr(E1 | H1)/Pr(E1 | ~H1) < Pr(E2 | H2)/Pr(E2 | ~H2)

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(declare-const s_7 Real)
(declare-const s_8 Real)
(declare-const s_9 Real)
(declare-const s_10 Real)
(declare-const s_11 Real)
(declare-const s_12 Real)
(declare-const s_13 Real)
(declare-const s_14 Real)
(assert (>= s_0 0))
(assert (>= s_1 0))
(assert (>= s_2 0))
(assert (>= s_3 0))
(assert (>= s_4 0))
(assert (>= s_5 0))
(assert (>= s_6 0))
(assert (>= s_7 0))
(assert (>= s_8 0))
(assert (>= s_9 0))
(assert (>= s_10 0))
(assert (>= s_11 0))
(assert (>= s_12 0))
(assert (>= s_13 0))
(assert (>= s_14 0))
(assert (<= (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7 s_8 s_9 s_10 s_11 s_12 s_13 s_14) 1))
(assert (not (= (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) 0)))
(assert (not (= (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))) 0)))
(assert (> (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) 0))
(assert (> (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11) 0))
(assert (> (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) 0))
(assert (> (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) 0))
(assert (> (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) 0))
(assert (> (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)) 0))
(assert (> (- (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7)) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) (- (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))
(assert (< (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)))) (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))))
(check-sat)

% However, it takes more than 1m to find a Regular model with this approach (does find one in under 2)
(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(declare-const s_7 Real)
(declare-const s_8 Real)
(declare-const s_9 Real)
(declare-const s_10 Real)
(declare-const s_11 Real)
(declare-const s_12 Real)
(declare-const s_13 Real)
(declare-const s_14 Real)
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_2 0))
(assert (> s_3 0))
(assert (> s_4 0))
(assert (> s_5 0))
(assert (> s_6 0))
(assert (> s_7 0))
(assert (> s_8 0))
(assert (> s_9 0))
(assert (> s_10 0))
(assert (> s_11 0))
(assert (> s_12 0))
(assert (> s_13 0))
(assert (> s_14 0))
(assert (<= (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7 s_8 s_9 s_10 s_11 s_12 s_13 s_14) 1))
(assert (not (= (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) 0)))
(assert (not (= (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))) 0)))
(assert (> (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) 0))
(assert (> (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11) 0))
(assert (> (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) 0))
(assert (> (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) 0))
(assert (> (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) 0))
(assert (> (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)) 0))
(assert (> (- (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7)) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) (- (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))
(assert (< (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)))) (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))))
(check-sat)

% However, simply adding a single marginal constraint to the original constraints yields a Regular model in <30s
% But, oddly, this gets slowed down if we move from "≠ 0" to "> 0" for the defined-ness conditions (see SMT code below)
Pr(H1 | E1) - Pr(H1) > Pr(H2 | E2) - Pr(H2)
Pr(E1 | H1)/Pr(E1 | ~H1) < Pr(E2 | H2)/Pr(E2 | ~H2)
Pr(H1) = 1/2

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(declare-const s_7 Real)
(declare-const s_8 Real)
(declare-const s_9 Real)
(declare-const s_10 Real)
(declare-const s_11 Real)
(declare-const s_12 Real)
(declare-const s_13 Real)
(declare-const s_14 Real)
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_2 0))
(assert (> s_3 0))
(assert (> s_4 0))
(assert (> s_5 0))
(assert (> s_6 0))
(assert (> s_7 0))
(assert (> s_8 0))
(assert (> s_9 0))
(assert (> s_10 0))
(assert (> s_11 0))
(assert (> s_12 0))
(assert (> s_13 0))
(assert (> s_14 0))
(assert (< (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7 s_8 s_9 s_10 s_11 s_12 s_13 s_14) 1))
(assert (not (= (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) 0)))
(assert (not (= (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))) 0)))
(assert (> (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) 0))
(assert (> (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11) 0))
(assert (> (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) 0))
(assert (> (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) 0))
(assert (> (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) 0))
(assert (> (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)) 0))
(assert (> (- (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7)) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) (- (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))
(assert (< (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)))) (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))))
(assert (= (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (/ 1 2)))
(check-sat)
(get-model)

% And, if we add 3 marginal constraints, then it instantly finds a regular model
% Moreover, this is NOT slowed down by moving from "≠ 0" to "> 0" (see SMT code below)
Pr(H1 | E1) - Pr(H1) > Pr(H2 | E2) - Pr(H2)
Pr(E1 | H1)/Pr(E1 | ~H1) < Pr(E2 | H2)/Pr(E2 | ~H2)
Pr(H1)=1/2
Pr(E1)=1/2
Pr(H2)=1/4

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(declare-const s_7 Real)
(declare-const s_8 Real)
(declare-const s_9 Real)
(declare-const s_10 Real)
(declare-const s_11 Real)
(declare-const s_12 Real)
(declare-const s_13 Real)
(declare-const s_14 Real)
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_2 0))
(assert (> s_3 0))
(assert (> s_4 0))
(assert (> s_5 0))
(assert (> s_6 0))
(assert (> s_7 0))
(assert (> s_8 0))
(assert (> s_9 0))
(assert (> s_10 0))
(assert (> s_11 0))
(assert (> s_12 0))
(assert (> s_13 0))
(assert (> s_14 0))
(assert (< (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7 s_8 s_9 s_10 s_11 s_12 s_13 s_14) 1))
(assert (not (= (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) 0)))
(assert (not (= (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))) 0)))
(assert (> (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) 0))
(assert (> (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11) 0))
(assert (> (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) 0))
(assert (> (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) 0))
(assert (> (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) 0))
(assert (> (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)) 0))
(assert (> (- (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7)) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) (- (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))
(assert (< (/ (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)))) (/ (+ s_0 s_2 s_8 s_10) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))))))
(assert (= (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (/ 1 2)))
(assert (= (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) (/ 1 2)))
(assert (= (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (/ 1 4)))
(check-sat)
(get-model)

% Another approach: eliminate ratios.  This usually helps a lot. Now it solves in under 20s (even with regularity checked)
% But, this IS slowed down if we move from "≠ 0" to "> 0" (see SMT code below)
Pr(H1 & E1) * Pr(E2) - Pr(H1) * Pr(E1) * Pr(E2) > Pr(H2 & E2) * Pr(E1) - Pr(H2) * Pr(E1) * Pr(E2)
Pr(E1 & H1) * Pr(E2 & ~H2) * Pr(H2) * Pr(~H1) < Pr(E2 & H2) * Pr(E1 & ~H1) * Pr(H1) * Pr(~H2)

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(declare-const s_7 Real)
(declare-const s_8 Real)
(declare-const s_9 Real)
(declare-const s_10 Real)
(declare-const s_11 Real)
(declare-const s_12 Real)
(declare-const s_13 Real)
(declare-const s_14 Real)
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_2 0))
(assert (> s_3 0))
(assert (> s_4 0))
(assert (> s_5 0))
(assert (> s_6 0))
(assert (> s_7 0))
(assert (> s_8 0))
(assert (> s_9 0))
(assert (> s_10 0))
(assert (> s_11 0))
(assert (> s_12 0))
(assert (> s_13 0))
(assert (> s_14 0))
(assert (< (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7 s_8 s_9 s_10 s_11 s_12 s_13 s_14) 1))
(assert (not (= (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) 0)))
(assert (not (= (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))) 0)))
(assert (> (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) 0))
(assert (> (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11) 0))
(assert (> (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) 0))
(assert (> (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) 0))
(assert (> (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) 0))
(assert (> (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)) 0))
(assert (> (- (* (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)) (* (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11))) (- (* (+ s_0 s_2 s_8 s_10) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7)) (* (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)))))
(assert (< (* (+ s_0 s_1 s_4 s_5) (+ s_1 s_3 s_9 s_11) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) (* (+ s_0 s_2 s_8 s_10) (+ s_2 s_3 s_6 s_7) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)))))
(check-sat)
(get-model)

% If we add the marginal constraints then it speeds up again (even with "> 0" used instead if "≠ 0")
Pr(H1 & E1) * Pr(E2) - Pr(H1) * Pr(E1) * Pr(E2) > Pr(H2 & E2) * Pr(E1) - Pr(H2) * Pr(E1) * Pr(E2)
Pr(E1 & H1) * Pr(E2 & ~H2) * Pr(H2) * Pr(~H1) < Pr(E2 & H2) * Pr(E1 & ~H1) * Pr(H1) * Pr(~H2)
Pr(H1)=1/2
Pr(E1)=1/2
Pr(H2)=1/4

(set-logic QF_NRA)
(declare-const s_0 Real)
(declare-const s_1 Real)
(declare-const s_2 Real)
(declare-const s_3 Real)
(declare-const s_4 Real)
(declare-const s_5 Real)
(declare-const s_6 Real)
(declare-const s_7 Real)
(declare-const s_8 Real)
(declare-const s_9 Real)
(declare-const s_10 Real)
(declare-const s_11 Real)
(declare-const s_12 Real)
(declare-const s_13 Real)
(declare-const s_14 Real)
(assert (> s_0 0))
(assert (> s_1 0))
(assert (> s_2 0))
(assert (> s_3 0))
(assert (> s_4 0))
(assert (> s_5 0))
(assert (> s_6 0))
(assert (> s_7 0))
(assert (> s_8 0))
(assert (> s_9 0))
(assert (> s_10 0))
(assert (> s_11 0))
(assert (> s_12 0))
(assert (> s_13 0))
(assert (> s_14 0))
(assert (< (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7 s_8 s_9 s_10 s_11 s_12 s_13 s_14) 1))
(assert (not (= (/ (+ s_2 s_3 s_6 s_7) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) 0)))
(assert (not (= (/ (+ s_1 s_3 s_9 s_11) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14))) 0)))
(assert (> (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) 0))
(assert (> (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11) 0))
(assert (> (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) 0))
(assert (> (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13)) 0))
(assert (> (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) 0))
(assert (> (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)) 0))
(assert (> (- (* (+ s_0 s_1 s_4 s_5) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)) (* (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11))) (- (* (+ s_0 s_2 s_8 s_10) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7)) (* (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) (+ s_0 s_1 s_2 s_3 s_8 s_9 s_10 s_11)))))
(assert (< (* (+ s_0 s_1 s_4 s_5) (+ s_1 s_3 s_9 s_11) (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (- 1 (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13))) (* (+ s_0 s_2 s_8 s_10) (+ s_2 s_3 s_6 s_7) (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (- 1 (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14)))))
(assert (= (+ s_0 s_1 s_4 s_5 s_8 s_9 s_12 s_13) (/ 1 2)))
(assert (= (+ s_0 s_1 s_2 s_3 s_4 s_5 s_6 s_7) (/ 1 2)))
(assert (= (+ s_0 s_2 s_4 s_6 s_8 s_10 s_12 s_14) (/ 1 4)))
(check-sat)
(get-model)

% easier example: showing d,r,s are not ordinally equivalent
Pr(X | Y) - Pr(X) > Pr(Y | X) - Pr(Y)
Pr(X | Y) - Pr(X | ~Y) < Pr(Y | X) - Pr(Y | ~X)
(Pr(X | Y) - Pr(X))/(Pr(X | Y) + Pr(X)) = (Pr(Y | X) - Pr(Y))/(Pr(Y | X) + Pr(Y))

% Quantitive Bounds for Simspon's Paradox
% d-measure
Pr(H | E & K) - Pr(H | K) = 1/3
Pr(H | E & ~K) - Pr(H | ~K) = 1/3
Pr(H | E) - Pr(H) = -1/3